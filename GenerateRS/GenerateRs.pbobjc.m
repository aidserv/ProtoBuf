// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GenerateRS.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "GenerateRs.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GenerateRsRoot

@implementation GenerateRsRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - GenerateRsRoot_FileDescriptor

static GPBFileDescriptor *GenerateRsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"AppleRemoteAuth"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - RemoteDeviceInfo

@implementation RemoteDeviceInfo

@dynamic rqData;
@dynamic rqSigData;
@dynamic grappaSessionId;
@dynamic fairPlayCertificate;
@dynamic fairDeviceType;
@dynamic fairPlayGuid;
@dynamic hasGrappa, grappa;
@dynamic hasDsid, dsid;
@dynamic hasKeyTypeSupportVersion, keyTypeSupportVersion;

typedef struct RemoteDeviceInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t grappaSessionId;
  NSData *rqData;
  NSData *rqSigData;
  NSData *fairPlayCertificate;
  NSString *fairPlayGuid;
  NSData *grappa;
  int64_t fairDeviceType;
  int64_t dsid;
  int64_t keyTypeSupportVersion;
} RemoteDeviceInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rqData",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoteDeviceInfo_FieldNumber_RqData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoteDeviceInfo__storage_, rqData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rqSigData",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoteDeviceInfo_FieldNumber_RqSigData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemoteDeviceInfo__storage_, rqSigData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "grappaSessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoteDeviceInfo_FieldNumber_GrappaSessionId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RemoteDeviceInfo__storage_, grappaSessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fairPlayCertificate",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoteDeviceInfo_FieldNumber_FairPlayCertificate,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RemoteDeviceInfo__storage_, fairPlayCertificate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fairDeviceType",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoteDeviceInfo_FieldNumber_FairDeviceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RemoteDeviceInfo__storage_, fairDeviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fairPlayGuid",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoteDeviceInfo_FieldNumber_FairPlayGuid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RemoteDeviceInfo__storage_, fairPlayGuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "grappa",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoteDeviceInfo_FieldNumber_Grappa,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RemoteDeviceInfo__storage_, grappa),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dsid",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoteDeviceInfo_FieldNumber_Dsid,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RemoteDeviceInfo__storage_, dsid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "keyTypeSupportVersion",
        .dataTypeSpecific.clazz = Nil,
        .number = RemoteDeviceInfo_FieldNumber_KeyTypeSupportVersion,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RemoteDeviceInfo__storage_, keyTypeSupportVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoteDeviceInfo class]
                                     rootClass:[GenerateRsRoot class]
                                          file:GenerateRsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoteDeviceInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\013\025\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - rsdata

@implementation rsdata

@dynamic rsData;
@dynamic ret;
@dynamic hasRsSigData, rsSigData;

typedef struct rsdata__storage_ {
  uint32_t _has_storage_[1];
  NSData *rsData;
  NSData *rsSigData;
} rsdata__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rsData",
        .dataTypeSpecific.clazz = Nil,
        .number = rsdata_FieldNumber_RsData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(rsdata__storage_, rsData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ret",
        .dataTypeSpecific.clazz = Nil,
        .number = rsdata_FieldNumber_Ret,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "rsSigData",
        .dataTypeSpecific.clazz = Nil,
        .number = rsdata_FieldNumber_RsSigData,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(rsdata__storage_, rsSigData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[rsdata class]
                                     rootClass:[GenerateRsRoot class]
                                          file:GenerateRsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(rsdata__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Grappa

@implementation Grappa

@dynamic grappaData;
@dynamic grappaSessionId;
@dynamic ret;

typedef struct Grappa__storage_ {
  uint32_t _has_storage_[1];
  uint32_t grappaSessionId;
  NSData *grappaData;
} Grappa__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "grappaData",
        .dataTypeSpecific.clazz = Nil,
        .number = Grappa_FieldNumber_GrappaData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Grappa__storage_, grappaData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "grappaSessionId",
        .dataTypeSpecific.clazz = Nil,
        .number = Grappa_FieldNumber_GrappaSessionId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Grappa__storage_, grappaSessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ret",
        .dataTypeSpecific.clazz = Nil,
        .number = Grappa_FieldNumber_Ret,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Grappa class]
                                     rootClass:[GenerateRsRoot class]
                                          file:GenerateRsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Grappa__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - rqGeneGrappa

@implementation rqGeneGrappa

@dynamic udid;

typedef struct rqGeneGrappa__storage_ {
  uint32_t _has_storage_[1];
  NSString *udid;
} rqGeneGrappa__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "udid",
        .dataTypeSpecific.clazz = Nil,
        .number = rqGeneGrappa_FieldNumber_Udid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(rqGeneGrappa__storage_, udid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[rqGeneGrappa class]
                                     rootClass:[GenerateRsRoot class]
                                          file:GenerateRsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(rqGeneGrappa__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - scinfo

@implementation scinfo

@dynamic appleid;
@dynamic dsid;
@dynamic hardwareInfo;
@dynamic sidb;
@dynamic sidd;

typedef struct scinfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *appleid;
  NSData *hardwareInfo;
  NSData *sidb;
  NSData *sidd;
  int64_t dsid;
} scinfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appleid",
        .dataTypeSpecific.clazz = Nil,
        .number = scinfo_FieldNumber_Appleid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(scinfo__storage_, appleid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dsid",
        .dataTypeSpecific.clazz = Nil,
        .number = scinfo_FieldNumber_Dsid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(scinfo__storage_, dsid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "hardwareInfo",
        .dataTypeSpecific.clazz = Nil,
        .number = scinfo_FieldNumber_HardwareInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(scinfo__storage_, hardwareInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sidb",
        .dataTypeSpecific.clazz = Nil,
        .number = scinfo_FieldNumber_Sidb,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(scinfo__storage_, sidb),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sidd",
        .dataTypeSpecific.clazz = Nil,
        .number = scinfo_FieldNumber_Sidd,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(scinfo__storage_, sidd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[scinfo class]
                                     rootClass:[GenerateRsRoot class]
                                          file:GenerateRsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(scinfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - rsscinfo

@implementation rsscinfo

@dynamic ret;

typedef struct rsscinfo__storage_ {
  uint32_t _has_storage_[1];
} rsscinfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.clazz = Nil,
        .number = rsscinfo_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[rsscinfo class]
                                     rootClass:[GenerateRsRoot class]
                                          file:GenerateRsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(rsscinfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
